---
title: "Impact of k on stochastic trajectories"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r libraries, include= FALSE}
library(ggplot2)
library(here)
library(dplyr)
library(reshape2)
library(doParallel)
library(foreach)
library(readr)
#library(RColorBrewer)
library(gridExtra) #for arranging plots side to side with grid.arrange
```

```{r parallelComputing, include = FALSE}

# Set Up for Parallel Computing

cores=detectCores()
cl <- makeCluster(cores[1]-1) #not to overload your computer
registerDoParallel(cl)


```


### Functions


```{r functions, include = FALSE}

# Load functions to run model:

source(here("Vfunctions", "V_stateUpdateT2.R")) # wrapper function, tracks epidemic in population over generations
source(here("Vfunctions", "V_DS_T2.R")) # updates state of population based on current generation
source(here("Vfunctions", "S_to_I_T2.R")) # simulation of infection with neg binom dist
source(here("Vfunctions", "effcIdGenT2.R")) # generating effective contact IDs
source(here("Vfunctions", "effcChecker.R")) # verifying effective contact IDs
source(here("Vfunctions", "reseedingT2.R")) # reseeding infection

```


```{r pEndemicity}

## Include function for calculating the proportion of simulations which become endemic for a given parameter set. ##

# Calculate proportion of simulations which become endemic

endemicity <- function(Tmat){ # input function is matrix of numbers infected across generations (columns) for multiple simulations (rows)
  
  P_endemic <- sum(Tmat[,ncol(Tmat)]!=0) / nrow(Tmat) # sum the number of simulations which result in 0 infections in the final generation (extinction), divided by the total number of simulaitons (number of row of matrix)

  return(P_endemic) # return the proportion of simulations which become endemic
}

```




### How does k impact endemicity: exporation of stochastic trajectories

To investigate how the value of k impacts endemicity explore individual stochastic trajectories for parameter combinations ($R0$, refractory period, k value) where a proportion of simulations result in extinction. 

#### Model Parameters

Based on previous exploration, parameter combinations for further investigation: 

* k = 0.3, R0=3, Refractory Period = 5 generations
  + ~60% simulations result in extinction

```{r quickPlot, include = FALSE, message = FALSE, warning=FALSE}
load(here("data_080121/k0-3List.RData"))

pars <- read_csv(here("data_080121/pars.csv"))

pEndemicity <- sapply(k0.3List, endemicity) # Apply endemicity function to kInfList to calculate proportion of simulations which become endemic for different parameter combinations
  
pEndemicitydf <- as.data.frame(cbind(pars,pEndemicity)) # Create a dataframe of proportion endmeic simulations and respective parameter combinations

plotdf <- pEndemicitydf %>% filter(R0 == 3)

ggplot(data = plotdf, aes(x = Rperiod, y = pEndemicity))+
  # geom_line()+
  geom_point()+
  geom_point(data=plotdf[3, ], aes(x=Rperiod, y=pEndemicity), colour="red")+

  scale_x_continuous(breaks = seq(1,11,2))+
  xlab("Refractory Period")+
  ylab("Proportion Endemicity (100 sims)")+
  theme_bw()

```





* Output = counts to track trajectory 

```{r pars1, eval = FALSE}

## Model Definition ##
runs <- 1
generations <- 1000 # the number of generations (or timesteps) to run the model over
output <- "counts" # defines the output as "matrix" (full disease state and ID of units) or "counts" (number of units in S,I,R states or "I_counts" (returns only count of infected units over time)

## Population Parameters ##

N <- 10000 # population size (may exxclude in favour of calculating in state_update function)
I0 <- 10
state_tracker <- c(rep("I", I0), rep("S", N - I0)) # initial disease state of units in population
population_sample <- "large" # large or small population (determines sampling strategy)

## Epidemiological Parameters ##

R_period <- 5 # the refractory period: 1 = no immunity, Inf = lifelong immunity
R0_estimate <- 3 # average number of effective contacts per unit
k_transmission <- 0.3 # overdispersion parameter, level of heterogeneity in effective contact potential: 0.1 = high heterogneiety, Inf = homogeneous

heterogeneity <- "fixed" # "fixed" or "variable", is unit transmission potential constant through time?
contact_list1 <- replicate(N, c(1:N), simplify = FALSE) 
contact_list <- lapply(1:length(contact_list1), 
                       function(x) contact_list1[[x]][-x]) 

## Reseeding Parameters ##
reseed <- TRUE # reseed 5 infections periodically during the first 10% of generations
reseed_threshold <- 100 # threshold generation for reseeding events
reseed_frequency <- 10
introductions <- 10 # number of new cases introduced when reseeding occurs

## Vaccination Parameters ##
V_prop <- 0 # proportion to be vaccinated in each round
V_start <- 0 # start generation for vaccination
V_period <- 0 # duration of immunity from vaccination (by number of timesteps)
V_rounds <- 0 # number of rounds (-1 for starting round) of vaccination in programme
V_schedule <- 0 # how frequent is vacciantion (ie every 2 "years")
V_mode <- "random" #random, target or non_target, NB: target/non-target only possible if heterogneiety is fixed

```


```{r runModel, eval = FALSE,include = FALSE}

## RUN MODEL ##

R_period <- 5 # the refractory period: 1 = no immunity, Inf = lifelong immunity
R0_estimate <- 3 # average number of effective contacts per unit
k_transmission <- 0.3 # overdispersion parameter, level of heterogeneity in effective contact potential: 0.1 = high heterogneiety, Inf = homogeneous


reps <- 10
testdf <- vector()

for(i in 1:reps){
  
   Runs_tracker <-
      #foreach (z = 1:runs, .combine = "rbind") %dopar% {
       state_update(
         
          state_tracker, # a vector of the the initial state of the population
          N, # population size (may exxclude in favour of calculating in state_update function)
          population_sample, # large or small population (determines sampling strategy)
          
          generations, # the number of generations (or timesteps) to run the model over
          output, # defines the output as "matrix" (full disease state and ID of units) or "counts" (number of units in S,I,R states or "I_counts" (returns only count of infected units over time)
          
          R_period, # the refractory period (number of timesteps that units are immune)
          R0_estimate, # average number of effective contacts per unit
          k_transmission, # overdispersion parameter, level of heterogeneity in effective contact potential
          heterogeneity, # is heterogeneity in effective contacts "fixed" or "variable"
          contact_list, # potential contacts of each unit 
          
          reseed, # reseed 5 infections periodically during the first 10% of generations
          reseed_threshold, # threshold generation for reseeding events
          reseed_frequency,
          introductions, # number of new cases introduced when reseeding occurs
          
          V_prop, # proportion to be vaccinated in each round
          V_start, # start generation for vaccination
          V_period, # duration of immunity from vaccination (by number of timesteps)
          V_rounds, # number of rounds (-1 for starting round) of vaccination in programme
          V_schedule, # how frequent is vacciantion (ie every 2 "years")
          V_mode #random, target or non_target
        )
        
     # }
    
    Runs_tracker$run <- i
    Runs_tracker$state <- c("S","I","R","V")
    
    testdf <- as.data.frame(rbind(testdf, Runs_tracker))
  
  
}

stochTraj_df <- melt(testdf, id.vars = c("run", "state"))


ggplot(data = stochTraj_df, aes(x = variable, y = value, group = state, colour = state))+
  geom_line()+
  facet_wrap(~run)+
  theme_bw()+
  scale_x_discrete(name = "Generation", breaks = seq(0,1000,100))+
  ylab("Incidence")

stochTraj_df %>% filter(run ==2 & state!="V") %>%
  ggplot(aes(x = variable, y = value, group = state, colour = state))+
  geom_line()+
  facet_wrap(~state)+
  theme_bw()+
  scale_x_discrete(name = "Generation", breaks = seq(0,1000,100))+
  ylab("Incidence")


```

```{r runModel, eval = FALSE,include = FALSE}

## RUN MODEL ##

R_period <- 9 # the refractory period: 1 = no immunity, Inf = lifelong immunity
R0_estimate <- 1.5 # average number of effective contacts per unit
k_transmission <- 0.1 # overdispersion parameter, level of heterogeneity in effective contact potential: 0.1 = high heterogneiety, Inf = homogeneous


reps <- 10
testdf <- vector()

for(i in 1:reps){
  
   Runs_tracker <-
      #foreach (z = 1:runs, .combine = "rbind") %dopar% {
       state_update(
         
          state_tracker, # a vector of the the initial state of the population
          N, # population size (may exxclude in favour of calculating in state_update function)
          population_sample, # large or small population (determines sampling strategy)
          
          generations, # the number of generations (or timesteps) to run the model over
          output, # defines the output as "matrix" (full disease state and ID of units) or "counts" (number of units in S,I,R states or "I_counts" (returns only count of infected units over time)
          
          R_period, # the refractory period (number of timesteps that units are immune)
          R0_estimate, # average number of effective contacts per unit
          k_transmission, # overdispersion parameter, level of heterogeneity in effective contact potential
          heterogeneity, # is heterogeneity in effective contacts "fixed" or "variable"
          contact_list, # potential contacts of each unit 
          
          reseed, # reseed 5 infections periodically during the first 10% of generations
          reseed_threshold, # threshold generation for reseeding events
          reseed_frequency,
          introductions, # number of new cases introduced when reseeding occurs
          
          V_prop, # proportion to be vaccinated in each round
          V_start, # start generation for vaccination
          V_period, # duration of immunity from vaccination (by number of timesteps)
          V_rounds, # number of rounds (-1 for starting round) of vaccination in programme
          V_schedule, # how frequent is vacciantion (ie every 2 "years")
          V_mode #random, target or non_target
        )
        
     # }
    
    Runs_tracker$run <- i
    Runs_tracker$state <- c("S","I","R","V")
    
    testdf <- as.data.frame(rbind(testdf, Runs_tracker))
  
  
}

stochTraj_df <- melt(testdf, id.vars = c("run", "state"))

ggplot(data = stochTraj_df, aes(x = variable, y = value, group = state, colour = state))+
  geom_line()+
  facet_wrap(~run)+
  theme_bw()+
  scale_x_discrete(name = "Generation", breaks = seq(0,1000,100))+
  ylab("Incidence")



```



